# module gauss

# export readMatrixFromFile, writeMatrixToFile

function readMatrixFromFile(filename::String)
    open(filename) do f
        lines = readlines(f)
        firstLine = lines[1]
        deleteat!(lines, 1)
        I = zeros(0)
        J = zeros(0)
        V = zeros(0)
#         k = 1 # debug
        n = parse(Int64, split(firstLine, r"\ |\t")[1])  # debug
        l = parse(Int64, split(firstLine, r"\ |\t")[2])  # debug
#         Q = zeros(Float64, n, n) # debug
        for line in lines
            splitLine = split(line, r"\ |\t")
#             println(splitLine[1], "|", splitLine[2], "|", splitLine[3])
            push!(I, parse(Int64, splitLine[1]))
            push!(J, parse(Int64, splitLine[2]))
            push!(V, parse(Float64, splitLine[3]))
#             println(I[k], "|", J[k], "|", V[k])
#             Q[Int(I[k]), Int(J[k])] = V[k]
#             k += 1
           end
        return sparse(I,J,V), n, l
    end
end

function writeMatrixToFile(matrix, filename, delim="\t")
    open(filename, "w") do file
          writedlm(file, matrix, delim)
    end
end


function LUdecompose(A, n)
    # A[wiersz, kolumna]
    for i in 1:(n-1)  # iterator kolumn
        for j in (i+1):n # utworzenie współczyników L i przechowanie poniżej przekątnej
            if A[j, i] == 0
                continue
            end
#             println("[ji] A[$j, $i]: ", A[j, i])
            A[j,i] = A[j,i]/A[i,i]
#             println("[ji] A[$j, $i]: ", A[j, i])
        end
        for k in (i+1):n         # odjęcie od równań równań pomnożonych przez współczynnik    
            for j in (i+1):n  
#                 println("[jk] A[$j, $i]: ", A[j, i])       
                A[j,k] = A[j,k] - A[j,i] * A[i,k]
#                 println("[jk] A[$j, $i]: ", A[j, i])
            end
        end
    end
end


# calculates Y and stores it in vector B. diagonal element of L are always ones.
function solveLyb(A, b, n)
#     println("i: 1, b[i]: $(b[1]), A[1, 1]: $(A[1,1])")
#     println("b[i]: $(b[1])")
    for i in 2:n
        Left = 0
        for j in i-1:-1:1
            Left += i==j ? b[j] : A[i, j] * b[j]
#             Left += A[i, j] * b[j]
        end
#         println("i: $i, b[i]: $(b[i]), Left: $Left, A[$i, $i]: 1.0")
        b[i] = (b[i]-Left)   # /A[i,i],  /1.0
#         println("b[i]: $(b[i])")
    end
end

# calculates X and stores it in vector Y
function solveUxy(A, y, n)
#     println("i: $n, y[i]: $(y[n]), A[$n, $n]: $(A[n, n])")
    y[n] = y[n]/A[n,n]
#     println("y[n]: $(y[n])")
    for i in (n-1):-1:1
        Left = 0
        for j in (i+1):n
            Left += A[i, j] * y[j]
        end
#         println("i: $i, y[i]: $(y[i]), Left: $Left, A[$i, $i]: $(A[i,i])")
        y[i] = (y[i]-Left)/A[i,i]
#         println("y[i]: $(y[i])")
    end
end
# end

#             if floor(j-1/n) == floor(i/j) # jesteśmy w A
#                 A[j,i] = A[j,i]/A[i,i]
#                continue 
#             end


sparseA, N, l = readMatrixFromFile("A.txt")
writeMatrixToFile(sparseA, "starting.csv")
LUdecompose(sparseA, N)
writeMatrixToFile(sparseA, "comp.csv")
b = ones(N)
solveLyb(sparseA, b, N)
writeMatrixToFile(sparseA, "calc.csv")
println(b)

# println(sparseA)
